<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>interview javascript | Jereky 的博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="JavaScript数组去重方法 ⭐1234567891011121314151617181920212223242526&#x2F;&#x2F; 利用对象的key值唯一function unique(arr)&#123;  var result &#x3D; &#123;&#125;;  for(var i &#x3D; 0; i &lt; arr.length; i++)&#123;    if(!result[arr[i]">
<meta property="og:type" content="article">
<meta property="og:title" content="interview javascript">
<meta property="og:url" content="https://mrjereky.github.io/2024/05/07/interview-javascript/index.html">
<meta property="og:site_name" content="Jereky 的博客">
<meta property="og:description" content="JavaScript数组去重方法 ⭐1234567891011121314151617181920212223242526&#x2F;&#x2F; 利用对象的key值唯一function unique(arr)&#123;  var result &#x3D; &#123;&#125;;  for(var i &#x3D; 0; i &lt; arr.length; i++)&#123;    if(!result[arr[i]">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/mrjereky/picgo/raw/master/typora/interview/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png">
<meta property="article:published_time" content="2024-05-07T05:56:35.000Z">
<meta property="article:modified_time" content="2024-07-10T09:52:29.590Z">
<meta property="article:author" content="Mr Jereky">
<meta property="article:tag" content="Interview">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/mrjereky/picgo/raw/master/typora/interview/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png">
  
    <link rel="alternative" href="/atom.xml" title="Jereky 的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/wy.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 7.2.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">Mr Jereky</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
						<!-- music -->
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Interview/" style="font-size: 20px;">Interview</a> <a href="/tags/browser/" style="font-size: 10px;">browser</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/network/" style="font-size: 10px;">network</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 10px;">工程化</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 10px;">浏览器</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">网络</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">I&#39;m a developer.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/avatar.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-interview-javascript" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/05/07/interview-javascript/" class="article-date">
  	<time datetime="2024-05-07T05:56:35.000Z" itemprop="datePublished">2024-05-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      interview javascript
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Interview/" rel="tag">Interview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>
	</div>

        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <meta name="referrer" content="no-referrer" />



<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="数组去重方法-⭐"><a href="#数组去重方法-⭐" class="headerlink" title="数组去重方法 ⭐"></a>数组去重方法 ⭐</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用对象的key值唯一</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!result[arr[i]])&#123;</span><br><span class="line">      result[arr[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用数组的includes</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!result.<span class="title function_">includes</span>(arr[i]))&#123;</span><br><span class="line">      result.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用Set</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>



<h2 id="new-操作符都做了什么-⭐"><a href="#new-操作符都做了什么-⭐" class="headerlink" title="new 操作符都做了什么 ⭐"></a>new 操作符都做了什么 ⭐</h2><p>通过new关键字创建一个对象实例</p>
<ol>
<li>首先创建一个空对象，{}</li>
<li>将空对象链接到另一个对象（设置对象的原型对象）</li>
<li>将1中创建的对象，作为this上下文</li>
<li>如果该构造函数没有返回对象，则返回this</li>
</ol>
<h2 id="this-的指向问题-如何改变-this-指向-⭐⭐"><a href="#this-的指向问题-如何改变-this-指向-⭐⭐" class="headerlink" title="this 的指向问题 如何改变 this 指向 ⭐⭐"></a>this 的指向问题 如何改变 this 指向 ⭐⭐</h2><p>this总是指向调用者。</p>
<ol>
<li>普通函数直接调用 &#x3D;&gt; 指向window全局</li>
<li>通过new构造函数调用 &#x3D;&gt; 指向实例对象</li>
<li>通过上下文对象调用 &#x3D;&gt; 指向调用对象</li>
<li>箭头函数 &#x3D;&gt; 自己没有this,继承外层作用域的this</li>
</ol>
<hr>
<p>改变this指向的方法有：call、apply、bind</p>
<p>call和apply直接调用</p>
<p>bind会返回一个新的函数，然后执行新的函数</p>
<h2 id="事件循环-⭐⭐⭐"><a href="#事件循环-⭐⭐⭐" class="headerlink" title="事件循环 ⭐⭐⭐"></a>事件循环 ⭐⭐⭐</h2><ol>
<li>在最开始的时候，渲染主线程会进入一个无限循环</li>
<li>每一次循环会检查消息队列中是否有任务存在，如果有，就取出第一个任务执行，执行完一个后进入下一次循环，如果没有，则进入休眠状态</li>
<li>其他所有线程（包括其他进程的线程）可以随时的向消息队列添加任务。新任务会添加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务</li>
</ol>
<p>这样一来，就可以让每个任务有条不紊，持续的进行下去。</p>
<p>整个过程称之为<strong>事件循环（消息循环）</strong></p>
<hr>
<p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。</p>
<p>在Chrome的源码中，他开启了一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p>
<p>过去把消息队列简单的分为宏队列和微队列，这种说法目前已经无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p>
<p>根据W3C官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同的任务队列又不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但是浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p>
<hr>
<p>除此之外的还有交互队列，网络队列，延迟队列…等等。在Chrome中，交互队列优先级要高于网络队列和延迟队列</p>
<p><img src="https://gitee.com/mrjereky/picgo/raw/master/typora/interview/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png"></p>
<h2 id="事件三要素-⭐"><a href="#事件三要素-⭐" class="headerlink" title="事件三要素 ⭐"></a>事件三要素 ⭐</h2><p>事件源、事件类型、事件处理程序</p>
<h2 id="事件监听-⭐"><a href="#事件监听-⭐" class="headerlink" title="事件监听 ⭐"></a>事件监听 ⭐</h2><p>首先要区分事件监听和事件监听器。</p>
<p>事件监听器又称之为事件处理程序，是事件触发后具体的行为。</p>
<p>事件监听包含三个阶段：捕获阶段、目标阶段、冒泡阶段</p>
<p>捕获阶段：事件对象从window全局经过祖先节点，一直传播到达目标节点，这个阶段称之为捕获阶段</p>
<p>目标阶段：事件对象到达事件目标，如果一个事件标记为不能茅冒泡，事件传播也就结束啦</p>
<p>冒泡阶段：事件对象从事件目标向上经过祖先节点，传播到window，这个阶段称之为冒泡阶段</p>
<h2 id="事件委托和冒泡原理-⭐"><a href="#事件委托和冒泡原理-⭐" class="headerlink" title="事件委托和冒泡原理 ⭐"></a>事件委托和冒泡原理 ⭐</h2><p>事件冒泡是指事件对象从目标节点向上传播，经过祖先节点，传播至window。</p>
<p>事件委托利用事件冒泡原理，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>
<p>例如 ul、li 列表，click事件会冒泡到ul层，所以直接给ul元素绑定事件，而不需要给每个li添加事件处理程序。</p>
<h2 id="阻止事件冒泡、默认行为-⭐"><a href="#阻止事件冒泡、默认行为-⭐" class="headerlink" title="阻止事件冒泡、默认行为 ⭐"></a>阻止事件冒泡、默认行为 ⭐</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻止默认行为</span></span><br><span class="line">event.<span class="title function_">preventDefault</span>();</span><br><span class="line"><span class="comment">// 阻止冒泡</span></span><br><span class="line">event.<span class="title function_">stopPropagation</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery中可以同时阻止默认行为、事件冒泡</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>



<h2 id="JS的数据类型-⭐⭐"><a href="#JS的数据类型-⭐⭐" class="headerlink" title="JS的数据类型 ⭐⭐"></a>JS的数据类型 ⭐⭐</h2><p>基本数据类型（存储栈区）：Number、String、Boolean、null、undefined、symbol、bigInt</p>
<p>引用数据类型（存储堆区）：object</p>
<p><strong>两者区别</strong>：</p>
<p>基本数据类型的访问、赋值、比较的是值，无法添加动态属性</p>
<p>引用数据类型的访问、赋值、比较的是引用地址，可以添加动态属性</p>
<h2 id="强制类型转换-⭐"><a href="#强制类型转换-⭐" class="headerlink" title="强制类型转换 ⭐"></a>强制类型转换 ⭐</h2><p>javaScript中数据类型转换。主要有三种</p>
<ol>
<li>转换函数</li>
</ol>
<p>例如js中提供了parseInt、parseFloat等转换函数</p>
<ol start="2">
<li>强制类型转换</li>
</ol>
<p>还可以强制类型的转换,例如：Boolean()、String()、Number()</p>
<ol start="3">
<li>JS变量的弱类型转换</li>
</ol>
<p>例如：</p>
<p>​    使用字符串拼接，转换成字符串</p>
<p>​    使用!!data，转换布尔</p>
<p>​    使用data*1，转换数值</p>
<h2 id="判断数据类型方法-⭐⭐"><a href="#判断数据类型方法-⭐⭐" class="headerlink" title="判断数据类型方法 ⭐⭐"></a>判断数据类型方法 ⭐⭐</h2><p>一劳永逸：使用<code>Object.prototype.toString.call(data)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> type = <span class="keyword">typeof</span> data;</span><br><span class="line">  <span class="keyword">if</span>(type !== <span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> type</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(data).<span class="title function_">replace</span>(<span class="regexp">/^\[object (\S+)\]$/</span>, <span class="string">&#x27;$1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可判断类型：number、string、boolean、 Array、RegExp、Date、Object......</span></span><br></pre></td></tr></table></figure>



<p>其他判断数据类型的方法：typeof、instanceof、constructor</p>
<h2 id="判断数组和对象-⭐"><a href="#判断数组和对象-⭐" class="headerlink" title="判断数组和对象 ⭐"></a>判断数组和对象 ⭐</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]	</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 instanceof</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// Array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  通过对象的 constructor 属性</span></span><br><span class="line">arr.<span class="property">constructor</span> === <span class="title class_">Array</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Array.isArray()</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 toString()</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr) <span class="comment">// [object Array]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;) <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure>



<h2 id="原型和原型链-⭐⭐⭐"><a href="#原型和原型链-⭐⭐⭐" class="headerlink" title="原型和原型链 ⭐⭐⭐"></a>原型和原型链 ⭐⭐⭐</h2><p>构造函数通过new关键字，创建一个对象实例</p>
<p>每个实例都有一个<code>__proto__</code>属性(隐式原型)，指向构造函数的原型</p>
<p>每个构造函数都有一个<code>prototype</code>属性，指向自己的原型</p>
<p>原型对象里面的<code>constructor</code>属性指向构造函数本身</p>
<p>至此，原型对象、构造函数、实例对象，像成了一个三角关系。</p>
<p>原型链：每个对象都有自己的原型对象，包括原型对象本身，从而形成了一条原型链。（终点是：<code>Object.prototype.__proto__</code> &#x3D;&gt; null）</p>
<p>当我们访问对象某个属性的时候，他会先从对象本身查找，如果本身没有此属性，会从原型上查找，以及原型的原型，依次向上，直到匹配到此属性或者原型链末尾为止。</p>
<h2 id="作用域和作用域链-⭐⭐"><a href="#作用域和作用域链-⭐⭐" class="headerlink" title="作用域和作用域链 ⭐⭐"></a>作用域和作用域链 ⭐⭐</h2><p>作用域有四种：全局作用域、函数作用域、块级作用域、eval作用域</p>
<p>作用域：代码中某些特定部分的变量、函数、对象的可访问性。</p>
<p>作用域链：当我们访问某个变量时，会先从当前作用域查找，如果没有会从上一级作用域查找，直到匹配或直到全局作用域为止，一层一层的关系就是作用域链</p>
<h2 id="闭包，应用场景，缺点和好处-⭐⭐"><a href="#闭包，应用场景，缺点和好处-⭐⭐" class="headerlink" title="闭包，应用场景，缺点和好处 ⭐⭐"></a>闭包，应用场景，缺点和好处 ⭐⭐</h2><p>闭包：一个函数和周围状态的引用捆绑在一起。闭包可以让你从内层函数访问到外层函数的作用域。</p>
<p>缺点：因为闭包的作用域链会引用包含他函数的对象，导致对象无法被销毁，占用系统内存，造成内存泄漏。</p>
<p>闭包有两种情况会导致内存泄漏</p>
<ol>
<li>当本应该销毁的函数没有销毁，导致和他关联的词法环境无法销毁，造成内存泄漏</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i++)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> func1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun1 = <span class="title function_">foo</span>()</span><br><span class="line"><span class="title function_">fun1</span>() </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>当多个函数共享一个词法环境时，可能导致词法环境的膨胀，从而导致出现无法触发但也无法回收的内存空间</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i++)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> func1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun1 = <span class="title function_">foo</span>()</span><br><span class="line"><span class="title function_">fun1</span>() </span><br></pre></td></tr></table></figure>



<p>闭包的应用场景：</p>
<ul>
<li>匿名自执行函数</li>
<li>结果缓存</li>
<li>封装</li>
<li>实现类和继承</li>
</ul>
<h2 id="内存泄漏-⭐⭐"><a href="#内存泄漏-⭐⭐" class="headerlink" title="内存泄漏 ⭐⭐"></a>内存泄漏 ⭐⭐</h2><p>程序中分配的堆内存由于某种原因未释放或者无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃</p>
<hr>
<p>不需要的、不可被访问的变量，没有从浏览器内存中销毁</p>
<h2 id="JS垃圾回收机制-⭐⭐⭐"><a href="#JS垃圾回收机制-⭐⭐⭐" class="headerlink" title="JS垃圾回收机制 ⭐⭐⭐"></a>JS垃圾回收机制 ⭐⭐⭐</h2><p>JS具有自动垃圾回收机制，垃圾收集器会按照固定时间间隔周期性的执行</p>
<p>JS垃圾回收方式：标记清除、引用计数</p>
<p><strong>标记清除</strong>：</p>
<p>原理：当变量进入环境会被标记为‘进入环境’，当变量离开环境会被标记为‘离开环境’， 标记为‘离开环境’的变量，会被回收内存</p>
<p><strong>引用计数</strong>：</p>
<p>原理：跟踪记录每个值被引用的次数</p>
<p>例如：</p>
<p>当我们声明一个变量，然后将一个引用类型的值赋值给变量。<code>[1,2,3]</code>的引用次数+1；</p>
<p>如果将另一个值赋值给变量，之前的<code>[1,2,3]</code>的引用次数-1；</p>
<p>如果引用次数为0，那么当垃圾收集器下次运行的时候，就会进行内存回收；</p>
<p>所以当我们有时候可以使用赋值为null的方式，进行释放内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3];</span><br><span class="line">arr = 123;</span><br><span class="line">arr = null;</span><br></pre></td></tr></table></figure>





<h2 id="深拷贝和浅拷贝-⭐⭐⭐"><a href="#深拷贝和浅拷贝-⭐⭐⭐" class="headerlink" title="深拷贝和浅拷贝 ⭐⭐⭐"></a>深拷贝和浅拷贝 ⭐⭐⭐</h2><p>浅拷贝：基本数据类型拷贝的是值，引用数据类型拷贝的是引用地址。</p>
<p>深拷贝：拷贝后的对象和之前的对象是 完全隔离的，互不影响。会在堆中重新分配内存，将源对象里面属性进行新建拷贝，重新生成新的引用类型。</p>
<p>深拷贝方法：</p>
<ol>
<li><p><code>JSON.parse(JSON.stringify())</code> ，只能深拷贝数组和对象，但不能处理函数</p>
</li>
<li><p>一劳永逸：手写递归的方式进行深拷贝</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">oldObj, newObj</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> oldObj)&#123;</span><br><span class="line">    <span class="keyword">var</span> item = oldObj[key];</span><br><span class="line">    <span class="comment">// 判断是否是对象</span></span><br><span class="line">    <span class="keyword">if</span>(item <span class="keyword">instanceof</span> <span class="title class_">Object</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(item <span class="keyword">instanceof</span> <span class="title class_">Function</span>)&#123;</span><br><span class="line">        newObj[key] = oldObj[key];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//判断是否是数组</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(item <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123;</span><br><span class="line">        newObj[key] = [];</span><br><span class="line">        <span class="title function_">deepCopy</span>(item, newObj[key])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        newObj[key] = &#123;&#125;;</span><br><span class="line">      	<span class="title function_">deepCopy</span>(item, newObj[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      newObj[key] = oldObj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ES6-新增特性-⭐⭐"><a href="#ES6-新增特性-⭐⭐" class="headerlink" title="ES6 新增特性 ⭐⭐"></a>ES6 新增特性 ⭐⭐</h2><ol>
<li>箭头函数</li>
<li>let、const</li>
<li>模块化导入导出（import export）</li>
<li>模板字符串</li>
<li>扩展操作符(…)、解构赋值</li>
<li>promise，async、await</li>
<li>Set、Map数据结构</li>
<li>……</li>
<li></li>
</ol>
<h2 id="箭头函数特点-⭐⭐"><a href="#箭头函数特点-⭐⭐" class="headerlink" title="箭头函数特点 ⭐⭐"></a>箭头函数特点 ⭐⭐</h2><ol>
<li>语法简洁</li>
<li>没有this、arguments，super</li>
<li>this指向上一层作用域，继承this</li>
</ol>
<h2 id="ES6为什么新增promise-promise的理解-⭐⭐⭐"><a href="#ES6为什么新增promise-promise的理解-⭐⭐⭐" class="headerlink" title="ES6为什么新增promise  promise的理解 ⭐⭐⭐"></a>ES6为什么新增promise  promise的理解 ⭐⭐⭐</h2><p>ES6之前，解决异步的方法是回调函数，但是回调函数最大的一个问题就是回调地狱，当我们的回调函数嵌套层数过多，就会导致代码横向发展。</p>
<p>promise的出现就是为了解决回调地狱的问题。</p>
<p>promise是异步编程的一种解决方案，比传统的回调函数和时间解决方案更强大合理。</p>
<p>特点：</p>
<p>promise对象的状态（状态不受外界影响）</p>
<ul>
<li>Pending（进行中）</li>
<li>Fulfilled（已成功）</li>
<li>Rejected（已失败）</li>
</ul>
<p>状态一旦改变就不会再变</p>
<ul>
<li>Pending–&gt;Fulfilled</li>
<li>Pending–&gt;Rejected</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">  <span class="comment">// some code ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="comment">/*异步操作成功*/</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="async、-await-⭐⭐"><a href="#async、-await-⭐⭐" class="headerlink" title="async、 await ⭐⭐"></a>async、 await ⭐⭐</h2><p>async：是一个修饰符，<code>async</code>定义的函数会默认返回一个promise对象resolve的值。因此可以直接对<code>async</code>函数进行<code>.then</code>操作，返回值就是then方法传入的函数。</p>
<p>await：关键字只能在<code>async</code>函数中使用，它的作用是获取promise中返回的内容。</p>
<h2 id="var、let、const-⭐⭐"><a href="#var、let、const-⭐⭐" class="headerlink" title="var、let、const ⭐⭐"></a>var、let、const ⭐⭐</h2><p>var：有变量提升，没有块的概念，可以跨块访问，不能跨函数访问，可以重复声明。</p>
<p>let：没有变量提升，只能在块级作用域中访问，不能跨块、跨函数访问，不能重复声明。</p>
<p>const： 没有变量提升，只能在块级作用域访问，定义常量，声明必须赋值，不能修改，不能重复声明。</p>
<h2 id="防抖、节流-⭐⭐"><a href="#防抖、节流-⭐⭐" class="headerlink" title="防抖、节流 ⭐⭐"></a>防抖、节流 ⭐⭐</h2><p>防抖：连续触发的事件，只执行最后一次，中间不执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timerId = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(timerId)&#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timerId);</span><br><span class="line">    &#125;</span><br><span class="line">    timerId = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="title function_">func</span>(...args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面有缺陷</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, duration</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timerId;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timerId);</span><br><span class="line">    <span class="comment">// 将该函数的this传递到fn</span></span><br><span class="line">    <span class="keyword">var</span> curThis = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 将该函数的参数全部传递给fn</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">slice</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    timerId = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(curThis, args);</span><br><span class="line">    &#125;, duration);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>节流：连续触发的事件，在n秒内只执行1次，2*n秒执行2次…稀释执行的频率</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context, args;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        context = <span class="variable language_">this</span>;</span><br><span class="line">        args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> args; <span class="comment">// 存储函数参数</span></span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>; <span class="comment">// 一开始的默认时间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 获取最新的时间戳</span></span><br><span class="line">        args = <span class="variable language_">arguments</span>; <span class="comment">// 获取参数</span></span><br><span class="line">        <span class="comment">// 进行时间戳的判断，如果超出规定时间，则执行</span></span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="comment">// timeout 存储计时器返回值</span></span><br><span class="line">    <span class="comment">// args 存储参数</span></span><br><span class="line">    <span class="keyword">var</span> timeout, args;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="comment">// 如果 timeout 有值，说明上一次的执行间隔时间还没过</span></span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            <span class="comment">// 进入此 if 说明时间间隔已经过了</span></span><br><span class="line">            <span class="comment">// 先执行一次要执行的函数</span></span><br><span class="line">            func.<span class="title function_">apply</span>(<span class="literal">null</span>, args)</span><br><span class="line">            <span class="comment">// 然后重新设置时间间隔</span></span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="冒泡排序-⭐"><a href="#冒泡排序-⭐" class="headerlink" title="冒泡排序 ⭐"></a>冒泡排序 ⭐</h2><p>比较相邻的两个元素，如果前一个比后一个大或者小（取决于排列顺序），交换位置。</p>
<p>比较完一轮，最后一个元素就是最大或者最小。</p>
<p>下一轮最后一个就不参与了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bSort</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;len-<span class="number">1</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j&lt;len-<span class="number">1</span>-i; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">        arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">        arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="sort排序-⭐"><a href="#sort排序-⭐" class="headerlink" title="sort排序 ⭐"></a>sort排序 ⭐</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;<span class="keyword">return</span> a -b &#125;)</span><br></pre></td></tr></table></figure>



<h2 id="数组降维-⭐"><a href="#数组降维-⭐" class="headerlink" title="数组降维 ⭐"></a>数组降维 ⭐</h2><p>数组降维可以使用flat方法，<code>var newArr = arr.flat(depth)</code></p>
<p>参数depth，指定提取嵌套数组结构的深度，默认值1；使用<code>Infinity</code>可以展开任意深度嵌套数组。</p>
<p>数组中有空项时，flat会将空项移除。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>]]];</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">flat</span>(); <span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br><span class="line">arr.<span class="title function_">flat</span>(<span class="number">2</span>); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr2.<span class="title function_">flat</span>(); <span class="comment">// [1,2,4,5]</span></span><br></pre></td></tr></table></figure>



<h2 id="两个数据求交集或合并-⭐"><a href="#两个数据求交集或合并-⭐" class="headerlink" title="两个数据求交集或合并 ⭐"></a>两个数据求交集或合并 ⭐</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">intersect</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = j = <span class="number">0</span>,</span><br><span class="line">        len1 = nums1.<span class="property">length</span>,</span><br><span class="line">        len2 = nums2.<span class="property">length</span>,</span><br><span class="line">        newArr = [];</span><br><span class="line">    <span class="keyword">if</span> (len1 === <span class="number">0</span> || len2 === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    nums1.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;);</span><br><span class="line">    nums2.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len1 || j &lt; len2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] === nums2[j]) &#123;</span><br><span class="line">                newArr.<span class="title function_">push</span>(nums1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; len1 - <span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; len2 - <span class="number">1</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">intersect</span>([<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]));</span><br></pre></td></tr></table></figure>



<h2 id="去除字符串中的空格-⭐⭐"><a href="#去除字符串中的空格-⭐⭐" class="headerlink" title="去除字符串中的空格 ⭐⭐"></a>去除字符串中的空格 ⭐⭐</h2><p>方法1：使用replace正则匹配方法</p>
<ul>
<li>去掉字符串内所有空格：<code>str = str.replace(/\s*/g,&quot;&quot;);</code></li>
<li>去掉字符串内两侧空格：<code>str = str.replace(/^\s*|\s*$/g,&quot;&quot;);</code></li>
<li>去掉字符串内左侧空格：<code>str = str.replace(/^\s*/,&quot;&quot;);</code></li>
<li>去掉字符串内右侧空格：<code>str = str.replace(/(\s*$)/g,&quot;&quot;);</code></li>
</ul>
<p>方法2：使用字符串原生<code>trim()</code>方法</p>
<p>trim可以去掉两侧空格返回新的字符串，不能去掉中间空格。</p>
<h2 id="实现一个-sleep-函数"><a href="#实现一个-sleep-函数" class="headerlink" title="实现一个 sleep 函数"></a>实现一个 sleep 函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">delay</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> start = (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">getTime</span>();</span><br><span class="line">  <span class="keyword">while</span>((<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">getTime</span>() - start &lt; delay)&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>柯里化（currying）又称为部分求值。一个柯里化函数首先会接受一些参数，接受这些参数后，该函数不会立即求值，而是继续返回另一个函数，刚传入的参数在函数中形成闭包被保存起来。待到函数真正需要求值的时候，之前传入的所有参数会被一次性用于求值。</p>
<h2 id="如何编写高性能的-JS-代码-⭐"><a href="#如何编写高性能的-JS-代码-⭐" class="headerlink" title="如何编写高性能的 JS 代码 ⭐"></a>如何编写高性能的 JS 代码 ⭐</h2><ul>
<li>遵守严格模式：<code>&quot;use strict&quot;</code></li>
<li>将JS脚本放在页面底部，加快页面渲染</li>
<li>将JS脚本成组打包，减少请求</li>
<li>使用非阻塞方式下载JS脚本</li>
<li>尽量使用局部变量来保存全局变量</li>
<li>减少使用闭包</li>
<li>使用window对象的属性方法时，省略window</li>
<li>减少对象成员的嵌套</li>
<li>缓存DOM节点的访问</li>
<li>避免使用<code>eval()</code>和<code>Function()</code>构造器</li>
<li>给<code>setTimeout</code>和<code>setInterval</code>传递函数而不是传递字符串作为参数</li>
<li>尽量使用直接量创建对象和数组</li>
<li>最小化重绘（repaint ）和回流（reflow）</li>
</ul>
<h2 id="继承的方式（继承的实现）"><a href="#继承的方式（继承的实现）" class="headerlink" title="继承的方式（继承的实现）"></a>继承的方式（继承的实现）</h2><ol>
<li>原型链继承</li>
<li>借用构造函数继承</li>
<li>组合继承（经典模式）</li>
<li>寄生组合继承（圣杯模式）</li>
</ol>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><h2 id="JS中的继承实现"><a href="#JS中的继承实现" class="headerlink" title="JS中的继承实现"></a>JS中的继承实现</h2><h2 id="proxy-代理对象"><a href="#proxy-代理对象" class="headerlink" title="proxy 代理对象"></a>proxy 代理对象</h2>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/05/07/interview-css/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          interview css
        
      </div>
    </a>
  
  
    <a href="/2024/05/07/interview-html/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">interview html</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2024 Mr Jereky
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>